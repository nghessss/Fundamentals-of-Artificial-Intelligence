\section{Implementation Idea and Code Description}
\subsection{Implementation Idea}
\qquad This project involves three main tasks:
\begin{enumerate}
    \item Reading images from various formats, such as .png, .jpg, and others.
    \item Selecting k-clusters to represent the colors, thereby reducing the original image's color palette.
    \item Applying the selected k-cluster colors to the original image and saving the result to a new file.
\end{enumerate}
\qquad The first and the third task would use PIL library to read and write the image

\qquad The second task use kmeans, which partitions the image's pixels into k clusters, with each cluster representing a dominant color.

\qquad \quad Because the first and third task just use the utilities of the PIL library so we would just explain the Algorithms that run in the second task

\subsubsection{Step-by-step Explanation}


\paragraph{KMeans Algorithms \cite{kmeansbrilliant}}
\quad

\qquad Step 1: K points are chosen to be centroids (in pixels or random mode) (this step would be show in \ref{sec:init centroid})

\qquad Step 2: Distances between every data point and the k centroids are calculated and stored.

\qquad Step 3: Based on distance calculates, each point is assigned to the nearest cluster

\qquad Step 4: New cluster centroid positions are updated: similar to finding a mean in the point locations

\qquad Step 5: If the centroid locations changed, the process repeats from step 2, until the calculated new center stays the same or the maximum number of iterations is reached, signaling that the clusters' members and centroids are now set.
\paragraph{Choose the initialized centroid}
\label{sec:init centroid}
\quad

\qquad There are two ways to choose initizalized centroid

\subparagraph{Randomly}
\qquad

\qquad The first way is to choose the pixels randomly in $[0;255]$

\subparagraph{In Pixels (Kmeans++ Algorithm) }
\qquad

\qquad The second way is also to choose the point randomly \textbf{in the dataset},

\qquad But to optimize the k-means algorithm, I suggest using the \textbf{k-means++ algorithm} , which helps the k-means to converge faster and improves the accuracy of the initial cluster centroids by strategically selecting them \cite{kmeanspluspluspaper}, thereby reducing the likelihood of poor clustering results.

\qquad \quad According to \cite{kmeanspluspluswiki}, Kmeans++ algorithms would run through these step to get k initial clusters

\qquad Step 1: Choose one center uniformly at random among the data points.

\qquad Step 2: For each data point x not chosen yet, compute $D(x)$, the distance between x and the nearest center that has already been chosen.

\qquad Step 3: Choose one new data point at random as a new center, using a weighted probability distribution where a point x is chosen with probability proportional to $D(x)^2$.

\qquad Step 4: Repeat Steps 2 and 3 until k centers have been chosen.

\qquad Step 5:Now that the initial centers have been chosen

\qquad \quad Here is a visualization to help you better understand \cite{kmeansplusplusyoutube}

\subsection{Code description}		
\subsubsection{read\_img(img\_path)}

\begin{verbatim}
    Read an image from a given path using PIL library

    zPARAMETERS
    ----------
    img_path : str
        Path of image

    RETURNS
    -------
        Image (2D): np.ndarray
    PSEUDOCODE
    ----------
    Open the image from img_path using a PIL library function
    Convert the opened image into a 2D numpy array
\end{verbatim}

\subsubsection{show\_img(img\_2d)}
\begin{verbatim}
    Show image using matplotlib library

    PARAMETERS
    ----------
    img_2d : <your type>
        Image (2D)
    
    PSEUDOCODE
    ----------
    Display the image using matplotlib.pyplot.imshow
    Turn off axis display
    Show the image
    
\end{verbatim}
\subsubsection{save\_img(img\_2d, img\_path)}
\begin{verbatim}
    Save image to img_path using PIL library

    PARAMETERS
    ----------
    img_2d : <your type>
        Image (2D)
    img_path : str
        Path of image
    
    PSEUDOCODE
    -------
    Convert img_2d to numpy array
    Ensure img_2d is of type uint8
    Convert numpy array img_2d to image
    Save image to img_path
\end{verbatim}
\subsubsection{convert\_img\_to\_1d(img\_2d)}
\begin{verbatim}
    Convert 2D image to 1D image using .reshape

    PARAMETERS
    ----------
    img_2d : <your type>
        Image (2D)

    RETURNS
    -------
        Image (1D): np.ndarray

    PSEUDOCODE
    -------
    Retrieve dimensions of the 2D image by .shape in numpy
    Reshape the 2D image into a 1D array by .reshape in nuby
\end{verbatim}
\subsubsection{kmeans(img\_1d, k\_clusters, max\_iter, init\_centroids='random')}
\begin{verbatim}
    K-Means algorithm

    PARAMETERS
    ----------
    img_1d : np.ndarray with shape=(height * width, num_channels)
        Original (1D) image
    k_clusters : int
        Number of clusters
    max_iter : int
        Max iterator
    init_centroids : str, default='random'
        The method used to initialize the centroids for K-means clustering
        'random' --> Centroids are initialized with random values between 0 and 255 for each channel
        'in_pixels' --> A random pixel from the original image is selected as a centroid for each cluster

    RETURNS
    -------
    centroids : np.ndarray with shape=(k_clusters, num_channels)
        Stores the color centroids for each cluster
    labels : np.ndarray with shape=(height * width, )
        Stores the cluster label for each pixel in the image

    PSEUDOCODE
    -------
    Initialize centroids based on the specified method ('random' or 'in_pixels')
    Iterate through a maximum number of iterations:
        Calculate distances between each pixel and centroids
        Assign each pixel to the closest centroid (labeling)
        Update centroids based on the mean of pixels assigned to each cluster
        Check if centroids have changed significantly
        If centroids have not changed, terminate the iteration
    Return the final centroids and labels
\end{verbatim}
\subsubsection{generate\_2d\_img(img\_2d\_shape, centroids, labels)}
\begin{verbatim}
    Generate a 2D image based on K-means cluster centroids
    PARAMETERS
    ----------
    img_2d_shape : tuple (height, width, 3)
        Shape of image
    centroids : np.ndarray with shape=(k_clusters, num_channels)
        Store color centroids
    labels : np.ndarray with shape=(height * width, )
        Store label for pixels (cluster's index on which the pixel belongs)

    RETURNS
    -------
        New image (2D)

    PSEUDOCODE
    -------
    Create an empty 2D image array with dimensions specified by img_2d_shape
    Iterate through each pixel in the image:
        Retrieve the centroid index from labels corresponding to the pixel
        Assign the centroid color values from centroids to the pixel in the new image
    Return the newly generated 2D image
\end{verbatim}
\subsubsection{initialize\_centroids(img\_1d, k\_clusters, init\_centroids = \'random\')}

\begin{verbatim}
    Initialize centroids for K-means clustering
    PARAMETERS
    ----------
    img_1d : np.ndarray with shape=(height * width, num_channels)
        Original (1D) image
    k_clusters : int
        Number of clusters
    init_centroids : str, default='random'
        The method used to initialize the centroids for K-means clustering
        'random' --> Centroids are initialized with random values between 0 and 255 for each channel
        'in_pixels' --> A random pixel from the original image is selected as a centroid for each cluster
    RETURNS
    -------
    centroids : np.ndarray with shape=(k_clusters, num_channels)
        Stores the color centroids for each cluster

    PSEUDOCODE
    -------
    If init_centroids is 'random':
        Initialize centroids randomly within the range [0, 255] for each channel, Ensure no duplicate centroids
    Else if init_centroids is 'in_pixels':
        Initialize centroids using k-means++ method
        Selects the first centroid randomly from img_1d.
        Calculates distances between each pixel and the last chosen centroid.
        Computes probabilities based on these distances and normalizes them.
        Iteratively selects the next centroid based on the calculated probabilities to ensure diversity.
        Copies the color values of selected centroids from img_1d to centroids.
    Return the initialized centroids array
\end{verbatim}
\pagebreak